general {
  base_exp_dir = "./exp"
  dataset_class = "models.dataset_loader.Dataset"
  device = "cpu"   # set to "cuda" for GPU runs
  # use a CPU fallback renderer for the tiny CPU baseline
  renderer_class = "models.renderer.CPUFallbackRenderer"
  recording = ["models","scripts"]
  pose_init_radius = 14.0
  pose_init_angle = 20.0
}

model {
  sdf_network {
    d_out = 1
    d_in = 3
    d_hidden = 64
    n_layers = 1
    skip_in = [-1]
    bias = 0.6
    geometric_init = True
    weight_norm = True
    input_concat = True
  }

  variance_network {
    init_val = 0.5
  }

  ray_marching {
    start_step_size = 1e-2
    end_step_size = 1e-3
    occ_threshold = 0.1
    occ_sigmoid_k = 80.0
    occ_resolution = 128
    occ_update_freq = 8
  }

  # No tiny-cuda-nn encoding for CPU baseline (tiny-cuda-nn requires CUDA)
  encoding = null

  LearnScale{
  existscalenet = False
  learn_scale = False
  scale_N = 1.0
  fix_scaleN = True
  }

   LearnPose{
  learn_pose = False
   }
}

dataset {
  # use one object from the diligent_mv_normals set for the tiny baseline
  data_dir = "./data/diligent_mv_normals/bear"
  normal_dir = "normal_camera_space_GT"
  depth_dir = "integration/depth"
  perspective_dir = "integration/perspective"
  cameras_name = "cameras_sphere.npz"
  exclude_views = []
  add_pose_noise = false
  rotation_noise_std = 0.0
  translation_noise_std = 0.0
  upsample_factor = 1
  depth_init_scale = 1.0
}

train {
  end_iter = 1
  batch_size = 1
  patch_size = 3
  learning_rate = 1e-4
  learning_rate_alpha = 0.1
  use_white_bkgd = false
  normal_weight_s1 = 1.0
  depth_weight_s1 = 0.0
  pc_weight_s1 = 0.0
  mask_weight_s1 = 0.0
  # Add a small eikonal + sdf regularization so CPU-only runs produce gradients
  # and allow a backward() to complete even when the renderer is a CPU fallback.
  eikonal_weight_s1 = 0.1
  sdf_weight_s1 = 0.01
  con_weight_s1 = 0.0
  val_normal_freq = 100000
  val_mesh_freq = 100000
  report_freq = 1
  save_freq = 1
  visual_pose_freq = 1
  pc_ratio = 8
  loss_type = "l1"
  gradient_method = "ad"
}

val {
  val_normal_freq = 100000
  val_normal_resolution_level = 1
  gradient_method = "ad"
  val_mesh_freq = 100000
  val_mesh_res = 256
  eval_metric_freq = 100000
  report_freq = 1
  save_freq = 1
  visual_pose_freq = 1
}
